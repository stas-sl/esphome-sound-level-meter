# yamllint disable rule:brackets rule:commas
---
esphome:
  name: sound-level-meter
  platformio_options:
    # I would recommend increasing CPU frequency, 
    # especially if you have many filters/sensors.
    board_build.f_cpu: 240000000

external_components:
  - source: github://stas-sl/esphome-sound-level-meter

esp32:
  board: esp32dev
  framework:
    type: arduino

logger:
  level: DEBUG

i2s:
  bck_pin: 23                   # also labeled as SCK
  ws_pin: 18
  din_pin: 19                   # also labeled as SD
  sample_rate: 48000            # default: 48000

  # Common settings are bits_per_sample: 16 and bits_shift: 0,
  # which should work for most microphones. A 16-bit resolution provides
  # a 96 dB dynamic range, sufficient to cover the dynamic range of most
  # MEMS microphones.
  # Alternatively, if your mic supports 24 bit resolution, you can
  # try bits_per_sample: 32 and bits_shift: 8
  bits_per_sample: 16           # default: 16
  mclk_multiple: 256            # default: 256
  dma_buf_count: 8              # default: 8
  dma_buf_len: 256              # default: 256
  use_apll: true                # default: false

  # according to datasheet when L/R pin is connected to GND,
  # the mic should output its signal in the left channel,
  # but on some boards I've encountered the opposite, 
  # so you can try both
  channel: right                # default: right

  # right shift samples.
  # for example if mic has 24 bit resolution, and
  # i2s configured as 32 bits, then audio data will be aligned left (MSB)
  # and LSB will be padded with zeros, so you might want to shift them right by 8 bits
  bits_shift: 0                 # default: 0

sound_level_meter:
  id: sound_level_meter1

  # update_interval specifies over which interval to aggregate audio data
  # you can specify default update_interval on top level, but you can also override
  # it further by specifying it on sensor level
  update_interval: 60s          # default: 60s

  # you can disable (turn off) component by default (on boot)
  # and turn it on later when needed via sound_level_meter.turn_on/toggle actions;
  # when used with switch it might conflict/being overriden by
  # switch state restoration logic, so you have to either disable it in
  # switch config and then is_on property here will have effect,
  # or completely rely on switch state restoration/initialization and
  # any value set here will be ignored
  is_on: true                   # default: true

  # buffer_size is in samples (not bytes), so for float data type
  # number of bytes will be buffer_size * 4
  buffer_size: 1024             # default: 1024

  # ignore audio data at startup for this long
  warmup_interval: 500ms        # default: 500ms

  # audio processing runs in a separate task, you can change its settings below
  task_stack_size: 4096         # default: 4096

  # idle task priority is 0,
  # main esphome loop priority is 1,
  # critical system tasks have priorities 18, 19, 20...
  # I set the priority to 2, slightly higher than the main loop,
  # because audio processing is highly sensitive to timing.
  # Large delays from certain components could cause the
  # DMA buffers to overflow, resulting in lost audio data.
  task_priority: 2              # default: 2
  task_core: 1                  # default: 1

  # see your mic datasheet to find sensitivity and reference SPL.
  # those are used to convert dB FS to db SPL

  # if omitted, the reported values will be in dB FS units
  mic_sensitivity: -26dB        # default: empty
  mic_sensitivity_ref: 94dB     # default: empty
  # additional offset if needed
  offset: 0dB                   # default: empty

  # under dsp_filters section you can define multiple filters,
  # which can be referenced later by each sensor

  # for now only SOS filter type is supported, see math/filter-design.ipynb
  # to learn how to create or convert other filter types to SOS

  # note, that those coefficients are only applicable for
  # specific sample rate (48 kHz in this case), so if you will use
  # other value, you have to update these coefficicients
  dsp_filters:
    - id: f_inmp441             # INMP441 mic eq @ 48kHz
      type: sos
      coeffs:
        #      b0            b1           b2          a1            a2
        - [1.0019784, -1.9908513, 0.9889158, -1.9951786, 0.99518436]
    - id: f_a                   # A weighting @ 48kHz
      type: sos
      coeffs:
        #       b0           b1            b2             a1            a2
        - [0.16999495, 0.741029, 0.52548885, -0.11321865, -0.056549273]
        - [1., -2.00027, 1.0002706, -0.03433284, -0.79215795]
        - [1., -0.709303, -0.29071867, -1.9822421, 0.9822986]
    - id: f_c                   # C weighting @ 48kHz
      type: sos
      coeffs:
        #       b0             b1             b2             a1             a2
        - [-0.49651518, -0.12296628, -0.0076134163, -0.37165618, 0.03453208]
        - [1., 1.3294908, 0.44188643, 1.2312505, 0.37899444]
        - [1., -2., 1., -1.9946145, 0.9946217]

  sensors:
    # 'eq' type sensor calculates Leq (average) sound level over specified period
    - type: eq
      name: LZeq_1s
      id: LZeq_1s
      # you can override updated_interval specified on top level
      # individually per each sensor
      update_interval: 1s

      # The dsp_filters field is a list of filter IDs defined
      # in the main component's corresponding section.
      # If you're only using a single filter, you can omit the brackets.
      # Alternatively, instead of referencing an existing filter,
      # you can define a filter directly here in the same format
      # as in the main component. However, this filter won't be reusable
      # across other sensors, so itâ€™s best to use this approach only when
      # each sensor requires its own unique filters that don't overlap with others.
      dsp_filters: [f_inmp441]

    # you can have as many sensors of same type, but with different
    # other parameters (e.g. update_interval) as needed
    - type: eq
      name: LZeq_1min
      id: LZeq_1min
      unit_of_measurement: dBZ
      # another syntax for specifying a list
      dsp_filters: 
        - f_inmp441

    # 'max' sensor type calculates Lmax with specified window_size.
    # for example, if update_interval is 60s and window_size is 1s
    # then it will calculate 60 Leq values for each second of audio data
    # and the result will be max of them
    - type: max
      name: LZmax_1s_1min
      id: LZmax_1s_1min
      window_size: 1s
      unit_of_measurement: dBZ
      # you can omit brackets, if there is only single element
      dsp_filters: f_inmp441

    # same as 'max', but 'min'
    - type: min
      name: LZmin_1s_1min
      id: LZmin_1s_1min
      window_size: 1s
      unit_of_measurement: dBZ
      # it is also possible to define filter right in place, 
      # though it would be considered as a different filter even
      # if it has the same coeffiecients as other defined filters, 
      # so previous calculations could not be reused, there
      dsp_filters:
        - type: sos
          coeffs:
            #       b0          b1          b2          a1          a2          
            - [ 1.0019784 , -1.9908513, 0.9889158 , -1.9951786, 0.99518436 ]

    # it finds max single sample over whole update_interval
    - type: peak
      name: LZpeak_1min
      id: LZpeak_1min
      unit_of_measurement: dBZ

    - type: eq
      name: LAeq_1min
      id: LAeq_1min
      unit_of_measurement: dBA
      dsp_filters: [f_inmp441, f_a]
    - type: max
      name: LAmax_1s_1min
      id: LAmax_1s_1min
      window_size: 1s
      unit_of_measurement: dBA
      dsp_filters: [f_inmp441, f_a]
    - type: min
      name: LAmin_1s_1min
      id: LAmin_1s_1min
      window_size: 1s
      unit_of_measurement: dBA
      dsp_filters: [f_inmp441, f_a]
    - type: peak
      name: LApeak_1min
      id: LApeak_1min
      unit_of_measurement: dBA
      dsp_filters: [f_inmp441, f_a]

    - type: eq
      name: LCeq_1min
      id: LCeq_1min
      unit_of_measurement: dBC
      dsp_filters: [f_inmp441, f_c]
    - type: max
      name: LCmax_1s_1min
      id: LCmax_1s_1min
      window_size: 1s
      unit_of_measurement: dBC
      dsp_filters: [f_inmp441, f_c]
    - type: min
      name: LCmin_1s_1min
      id: LCmin_1s_1min
      window_size: 1s
      unit_of_measurement: dBC
      dsp_filters: [f_inmp441, f_c]
    - type: peak
      name: LCpeak_1min
      id: LCpeak_1min
      unit_of_measurement: dBC
      dsp_filters: [f_inmp441, f_c]

# automation
# available actions:
#   - sound_level_meter.turn_on
#   - sound_level_meter.turn_off
#   - sound_level_meter.toggle
switch:
  - platform: template
    name: "Sound Level Meter Switch"
    icon: mdi:power
    # if you want is_on property on component to have effect, then set
    # restore_mode to DISABLED, or alternatively you can use other modes
    # (more on them in esphome docs), then is_on property on the component will
    # be overriden by the switch
    restore_mode: DISABLED # ALWAYS_OFF | ALWAYS_ON | RESTORE_DEFAULT_OFF | RESTORE_DEFAULT_ON
    lambda: |-
      return id(sound_level_meter1).is_on();
    turn_on_action:
      - sound_level_meter.turn_on
    turn_off_action:
      - sound_level_meter.turn_off

button:
  - platform: template
    name: "Sound Level Meter Toggle Button"
    on_press:
      - sound_level_meter.toggle: sound_level_meter1

binary_sensor:
  - platform: gpio
    pin: GPIO0
    name: "Sound Level Meter GPIO Toggle"
    on_press:
      - sound_level_meter.toggle: sound_level_meter1
